<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Include directive</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
  </head>
  <body>
    <div class="p-5 mb-4 bg-light rounded-3">
        <div class="container-fluid py-5">
          <h1 class="display-5 fw-bold">Language Support</h1>
          <p class="col-md-8 fs-4">C/C++

In the C and C++ programming languages, the #include preprocessor directive causes the compiler to replace that line with the entire text of the contents of the named source file (if included in quotes: "") or named header (if included in angle brackets: <>);[2] note that a header doesn't need to be a source file.[3] Inclusion continues recursively on these included contents, up to an implementation-defined nesting limit. Headers need not have names corresponding to files: in C++ standard headers are typically identified with words, like "vector", hence #include <vector>, while in C standard headers have identifiers in the form of filenames with a ".h" extension, as in #include <stdio.h>. A "source file" can be any file, with a name of any form, but is most commonly named with a ".h" extension and called a "header file" (sometimes ".hpp" or ".hh" to distinguish C++ headers), though files with .c, .cc, and .cpp extensions may also be included (particularly in the single compilation unit technique), and sometimes other extensions are used.

These two forms of #include directive can determine which header or source file to include in an implementation-defined way. In practice, what is usually done is that the angle-brackets form searches for source files in a standard system directory (or set of directories), and then searches for source files in local or project-specific paths (specified on the command line, in an environment variable, or in a Makefile or other build file), while the form with quotes does not search in a standard system directory, only searching in local or project-specific paths.[4] In case there is no clash, the angle-brackets form can also be used to specify project-specific includes, but this is considered poor form. The fact that headers need not correspond to files is primarily an implementation technicality, and is used to omit the .h extension in including C++ standard headers; in common use, "header" means "header file".

For example:

#include <stdio.h>  // Include the contents of the standard header 'stdio.h' (probably a file 'stdio.h').
#include <vector>  // Include the contents of the standard header 'vector' (probably a file 'vector.h').
#include "user_defined.h"  // Include the contents of the file 'user_defined.h'.

In C and C++, problems may be faced if two (or more) include files contain the same third file. One solution is to avoid include files from including any other files, possibly requiring the programmer to manually add extra include directives to the original file. Another solution is to use include guards.[5]
COBOL

COBOL (and also RPG IV) allows programmers to copy copybooks into the source of the program in a similar way to header files, but it also allows for the replacement of certain text in them with other text. The COBOL keyword for inclusion is COPY, and replacement is done using the REPLACING ... BY ... clause. An include directive has been present in COBOL since COBOL 60, but changed from the original INCLUDE[6] to COPY by 1968.[7]
Fortran

Fortran does not require header files per se. However, Fortran 90 and later have two related features: include statements and modules. The former can be used to share a common file containing procedure interfaces, much like a C header, although the specification of an interface is not required for all varieties of Fortran procedures. This approach is not commonly used; instead, procedures are generally grouped into modules that can then be referenced with a use statement within other regions of code. For modules, header-type interface information is automatically generated by the compiler and typically put into separate module files, although some compilers have placed this information directly into object files. The language specification itself does not mandate the creation of any extra files, even though module procedure interfaces are almost universally propagated in this manner.
Pascal

Most Pascal compilers support the $i or $include compiler directive, in which the $i or $include directive immediately follows the start of a comment block in the form of

    {$i filename.pas}
    (*$I filename.inc*)
    {$include filename.inc}
    (*INCLUDE filename.pas*)

Where the $i or $include directive is not case sensitive, and filename.pas or filename.inc is the name of the file to be included. (It has been common practice to name Pascal's include files with the extension .inc, but this is not required.) Some compilers, to prevent crock recursion, limit invoking an include file to a certain number, prohibit invoking itself or any currently open file, or are limited to a maximum of one include file at a time, e.g. an include file cannot include itself or another file. However, the program that includes other files can include several, just one at a time.
PHP

In PHP, the include directive causes another PHP file to be included and evaluated.[8] Similar commands are require, which upon failure to include will produce a fatal exception and halt the script,[9] and include_once and require_once, which prevent a file from being included or required again if it has already been included or required, avoiding the C's double inclusion problem.
Other languages

There are many forms of the include directive, such as:

    include ... (Fortran, MASM)
    <!--#include ... --> (HTML SSI)
    import ...; (Java)
    import ... from ... (JavaScript as in ECMAScript)
    var ... = require("...") (JavaScript with CommonJS)
    <%@ include ... %> (JSP)
    {$I ...} (UCSD Pascal, Turbo Pascal)
    %include ... (PL/I)
    import ... (Python)
    /COPY QCPYLESRC,QBC (RPG IV â€“ first argument is the filename, second argument is the copybook)
    use ...; (Rust)
    using ...; (C#)
    local ... = require("...") (Lua)
    import ...; (D)

Modern languages (e.g. Haskell and Java) tend to avoid copybooks or includes, preferring modules and import/export systems for namespace control. Some of these languages (such as Java and C#) do not use forward declarations and, instead, identifiers are recognized automatically from source files and read directly from dynamic library symbols (typically referenced with import or using directives), meaning header files are not needed. </p>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
  </body>
</html>
